import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Arrays;

class CMAC {

    private static final byte[] irrPoly = {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte) 0x87
    };

    private final SecretKey key;

    private byte[] k1, k2;

    public CMAC(SecretKey key) throws Exception {
        this.key = key;

        generateSubkeys();

        System.out.println("k " + CCM.byteArrayToHexString(key.getEncoded()));
        System.out.println("k1 " + CCM.byteArrayToHexString(k1));
        System.out.println("k2 " + CCM.byteArrayToHexString(k2) + "\n");
    }

    public static byte[] gfMult(byte[] toMult) {
        byte[] result = shiftLeft(toMult);

        if ((toMult[0] & 0x80) != 0) {
            result = xor(result, irrPoly);
        }

        return result;
    }

    private static byte[] shiftLeft(byte[] input) {
        byte[] output = new byte[input.length];
        int carry = 0;

        for (int i = input.length - 1; i >= 0; i--) {
            output[i] = (byte) ((input[i] << 1) | carry);
            carry = (input[i] & 0x80) != 0 ? 1 : 0;
        }

        return output;
    }

    private static byte[] xor(byte[] a, byte[] b) {
        byte[] result = new byte[a.length];

        for (int i = 0; i < a.length; i++) {
            result[i] = (byte) (a[i] ^ b[i]);
        }

        return result;
    }

    private void generateSubkeys() throws Exception {
        byte[] zeroes = new byte[16];
        byte[] l = encrypt(zeroes);

        k1 = shiftLeft(l);

        if ((l[0] & 0x80) != 0) {
            k1 = xor(k1, irrPoly);
        }

        k2 = shiftLeft(k1);

        if ((k1[0] & 0x80) != 0) {
            k2 = xor(k2, irrPoly);
        }
    }

    public byte[] authentify(byte[] message) throws Exception {
        int blockSize = 16;
        int messageLength = message.length;
        int numberOfBlocks = (messageLength + blockSize - 1) / blockSize;
        boolean lastBlockComplete = (messageLength % blockSize == 0);

        byte[] mPrev = new byte[blockSize];

        if (numberOfBlocks == 0) {
            numberOfBlocks = 1;
            lastBlockComplete = false;
        }

        for (int i = 0; i < numberOfBlocks - 1; i++) {
            byte[] block = new byte[blockSize];
            System.arraycopy(message, i * blockSize, block, 0, blockSize);

            // Print Full Blocks
            System.out.println("Full Block " + i + ": " + CCM.byteArrayToHexString(block));

            mPrev = xor(encrypt(xor(mPrev, block)), new byte[blockSize]);
        }

        byte[] lastBlock = new byte[blockSize];

        if (lastBlockComplete) {
            System.arraycopy(message, (numberOfBlocks - 1) * blockSize, lastBlock, 0, blockSize);
            lastBlock = xor(lastBlock, k1);
        } else {
            System.arraycopy(message, (numberOfBlocks - 1) * blockSize, lastBlock, 0, messageLength % blockSize);
            lastBlock[messageLength % blockSize] = (byte) 0x80;
            lastBlock = xor(lastBlock, k2);
        }

        System.out.println("Last Block: " + CCM.byteArrayToHexString(lastBlock));
        mPrev = xor(encrypt(xor(mPrev, lastBlock)), new byte[blockSize]);

        return mPrev;
    }


    private byte[] encrypt(byte[] input) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/ECB/NoPadding");
        cipher.init(Cipher.ENCRYPT_MODE, key);

        return cipher.doFinal(input);
    }

}

public class CCM {

    SecretKey key;

    public CCM(SecretKey key) {
        this.key = key;
    }

    public static byte[] hexStringToByteArray(String hex) {//generated by ChatGPT
        if (hex.length() % 2 == 1)
            hex = "0" + hex;
        int len = hex.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4) + Character.digit(hex.charAt(i + 1), 16));
        }
        return data;
    }

    public static String byteArrayToHexString(byte[] byteArray) {
        return byteArrayToHexStringWithSpacing(byteArray, 4);
    }

    public static String byteArrayToHexStringWithSpacing(byte[] byteArray, int blockSize) {
        StringBuilder hexString = new StringBuilder();

        for (int i = 0; i < byteArray.length; i++) {
            hexString.append(String.format("%02X", byteArray[i]));

            if ((i + 1) % blockSize == 0 && (i + 1) < byteArray.length) {
                hexString.append(" ");
            }
        }

        return hexString.toString();
    }

    public static byte[] formatedTagInput(byte[] nonce, byte[] assData, byte[] plaintext, int tlen) {
        byte[] formatedNonce = new byte[16];
        formatedNonce[0] |= 0x40;

        int t = (tlen - 2) / 2;
        formatedNonce[0] |= (byte) (((t % 2) + (((t / 2) % 2) * 2) + (((t / 4) % 2)) * 4) * 8);

        int q = 14 - nonce.length;
        formatedNonce[0] |= (byte) (q % 2 + ((q / 2) % 2) * 2 + (((q / 4) % 2) * 4));

        System.arraycopy(nonce, 0, formatedNonce, 1, nonce.length);

        String pHex = Integer.toHexString(plaintext.length);

        byte[] pByte = CCM.hexStringToByteArray(pHex);

        for (int i = 0; i < pByte.length; i++) {
            formatedNonce[16 + i - pByte.length] |= pByte[i];
        }

        byte[] formatedAssData;

        if (assData.length > 0) {
            if (assData.length < 65280) {

                formatedAssData = new byte[2 + assData.length + ((2 + assData.length) % 16 == 0 ? 0 : 16 - ((2 + assData.length) % 16))];
                formatedAssData[0] = (byte) (assData.length / 256);
                formatedAssData[1] = (byte) (assData.length % 256);

                System.arraycopy(assData, 0, formatedAssData, 2, assData.length);
            } else {
                formatedAssData = new byte[6 + assData.length + ((6 + assData.length) % 16 == 0 ? 0 : 16 - ((6 + assData.length) % 16))];
                formatedAssData[0] = (byte) 0xff;
                formatedAssData[1] = (byte) 0xfe;

                int a = assData.length;

                for (int i = 0; i < 6; ++i) {
                    formatedAssData[7 - i] = (byte) (a % 256);
                    a /= 256;
                }

                System.arraycopy(assData, 0, formatedAssData, 6, assData.length);
            }
        } else {
            formatedAssData = new byte[0];
        }

        byte[] formatedPlaintext = new byte[plaintext.length + (plaintext.length % 16 == 0 ? 0 : 16 - (plaintext.length % 16))];

        System.arraycopy(plaintext, 0, formatedPlaintext, 0, plaintext.length);

        byte[] input = new byte[formatedNonce.length + formatedAssData.length + formatedPlaintext.length];

        System.arraycopy(formatedNonce, 0, input, 0, formatedNonce.length);

        System.arraycopy(formatedAssData, 0, input, formatedNonce.length, formatedAssData.length);

        for (int i = 0; i < formatedPlaintext.length; i++) {
            input[i + formatedNonce.length + formatedAssData.length] = formatedPlaintext[i];
        }

        return input;
    }

    public static IvParameterSpec formatedCounter(byte[] nonce) {
        byte[] formatedCounter = new byte[16];
        int q = 14 - nonce.length;

        formatedCounter[0] |= (byte) (q % 2 + ((q / 2) % 2) * 2 + ((((q / 4) % 2)) * 4));

        System.arraycopy(nonce, 0, formatedCounter, 1, nonce.length);

        return new IvParameterSpec(formatedCounter);
    }

    public static void main(String[] args) throws Exception {
        String key = "2B7E151628AED2A6ABF7158809CF4F3C";
        byte[] keyBytes = CCM.hexStringToByteArray(key);
        SecretKey secretKey = new SecretKeySpec(keyBytes, "AES");

        String key2 = "404142434445464748494A4B4C4D4E4F";
        byte[] keyBytes2 = CCM.hexStringToByteArray(key2);
        SecretKey secretKey2 = new SecretKeySpec(keyBytes2, "AES");

        CMAC cmac = new CMAC(secretKey);

        byte[] messageByte = new byte[0];
        byte[] macValue = cmac.authentify(messageByte);

        System.out.println("Tag is " + byteArrayToHexString(macValue) + "\n");

        String message = "6BC1BEE22E409F96E93D7E117393172A";
        messageByte = CCM.hexStringToByteArray(message);
        macValue = cmac.authentify(messageByte);
        System.out.println("Tag is " + byteArrayToHexString(macValue) + "\n");

        message = "6BC1BEE22E409F96E93D7E117393172AAE2D8A57";
        messageByte = CCM.hexStringToByteArray(message);
        macValue = cmac.authentify(messageByte);
        System.out.println("Tag is " + byteArrayToHexString(macValue) + "\n");

        message = "6BC1BEE22E409F96E93D7E117393172AAE2D8A571E03AC9C9EB76FAC45AF8E5130C81C46A35CE411E5FBC1191A0A52EFF69F2445DF4F9B17AD2B417BE66C3710";
        messageByte = CCM.hexStringToByteArray(message);
        macValue = cmac.authentify(messageByte);
        System.out.println("Tag is " + byteArrayToHexString(macValue) + "\n");

        System.out.println("\nExample #1");
        String nonce = "10111213141516", assData = "0001020304050607", plaintext = "20212223";
        byte[] nonceByte = CCM.hexStringToByteArray(nonce), assDataByte = CCM.hexStringToByteArray(assData), plaintextByte = CCM.hexStringToByteArray(plaintext);

        CCM ccm = new CCM(secretKey2);

        byte[] cypher = ccm.encryptGenerate(nonceByte, assDataByte, plaintextByte, 4);
        System.out.println(CCM.byteArrayToHexString(cypher));

        System.out.println("cyp " + byteArrayToHexString(cypher));

        byte[] decypher = ccm.decryptVerify(nonceByte, assDataByte, cypher, 4);
        System.out.println(CCM.byteArrayToHexString(decypher));

        System.out.println("\nExample #2");
        String nonce2 = "1011121314151617", assData2 = "000102030405060708090A0B0C0D0E0F", plaintext2 = "202122232425262728292A2B2C2D2E2F";
        byte[] nonceByte2 = CCM.hexStringToByteArray(nonce2), assDataByte2 = CCM.hexStringToByteArray(assData2), plaintextByte2 = CCM.hexStringToByteArray(plaintext2);
        CCM ccm2 = new CCM(secretKey2);

        byte[] cypher2 = ccm2.encryptGenerate(nonceByte2, assDataByte2, plaintextByte2, 6);
        System.out.println(CCM.byteArrayToHexString(cypher2));

        byte[] decypher2 = ccm2.decryptVerify(nonceByte2, assDataByte2, cypher2, 6);
        System.out.println(CCM.byteArrayToHexString(decypher2));

        System.out.println("\nExample #3");
        String nonce3 = "101112131415161718191A1B", assData3 = "000102030405060708090A0B0C0D0E0F10111213", plaintext3 = "202122232425262728292A2B2C2D2E2F3031323334353637";
        byte[] nonceByte3 = CCM.hexStringToByteArray(nonce3), assDataByte3 = CCM.hexStringToByteArray(assData3), plaintextByte3 = CCM.hexStringToByteArray(plaintext3);

        CCM ccm3 = new CCM(secretKey2);

        byte[] cypher3 = ccm3.encryptGenerate(nonceByte3, assDataByte3, plaintextByte3, 8);
        System.out.println(CCM.byteArrayToHexString(cypher3));

        byte[] decypher3 = ccm3.decryptVerify(nonceByte3, assDataByte3, cypher3, 8);
        System.out.println(CCM.byteArrayToHexString(decypher3));
    }

    public byte[] tag(byte[] nonce, byte[] additionalData, byte[] plainText, int tagLength) throws Exception {
        byte[] formated = formatedTagInput(nonce, additionalData, plainText, tagLength);

        Cipher aesCipher = Cipher.getInstance("AES/CBC/NoPadding");
        aesCipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(new byte[16]));

        byte[] cipher = aesCipher.doFinal(formated);

        byte[] tag = new byte[tagLength];
        System.arraycopy(cipher, cipher.length - 16, tag, 0, tagLength);

        return tag;
    }

    public byte[] encryptGenerate(byte[] nonce, byte[] additionalData, byte[] plainText, int tagLength) throws Exception {
        printDebugInfo(nonce, additionalData, plainText, tagLength);

        byte[] tag = tag(nonce, additionalData, plainText, tagLength);
        Cipher ctrCipher = Cipher.getInstance("AES/CTR/NoPadding");

        IvParameterSpec counter = formatedCounter(nonce);

        ctrCipher.init(Cipher.ENCRYPT_MODE, key, counter);
        byte[] cipherTag = ctrCipher.doFinal(tag);

        byte[] counterPlus1Bytes = counter.getIV();
        ++counterPlus1Bytes[counterPlus1Bytes.length - 1];
        IvParameterSpec counterPlus1 = new IvParameterSpec(counterPlus1Bytes);

        ctrCipher.init(Cipher.ENCRYPT_MODE, key, counterPlus1);
        byte[] cipherText = ctrCipher.doFinal(plainText);

        byte[] concatenated = new byte[cipherText.length + cipherTag.length];
        System.arraycopy(cipherText, 0, concatenated, 0, cipherText.length);
        System.arraycopy(cipherTag, 0, concatenated, cipherText.length, cipherTag.length);

        return concatenated;
    }

    private void printDebugInfo(byte[] nonce, byte[] assData, byte[] plaintext, int tagLength) throws Exception {
        System.out.println("Klen = " + key.getEncoded().length * 8);
        System.out.println("Tlen = " + tagLength * 8);
        System.out.println("Nlen = " + nonce.length * 8);
        System.out.println("Alen = " + assData.length * 8);
        System.out.println("Plen = " + plaintext.length * 8);
        System.out.println("\nK is " + byteArrayToHexString(key.getEncoded()));
        System.out.println("N is " + byteArrayToHexString(nonce));
        System.out.println("A is " + byteArrayToHexString(assData));
        System.out.println("P is " + byteArrayToHexString(plaintext));
        System.out.println("\nB " + byteArrayToHexString(formatedTagInput(nonce, assData, plaintext, tagLength)));
        System.out.println("T " + byteArrayToHexString(tag(nonce, assData, plaintext, tagLength)));
    }

    public byte[] decryptVerify(byte[] nonce, byte[] additionalData, byte[] cipher, int tagLength) throws Exception {
        byte[] cipherText = Arrays.copyOfRange(cipher, 0, cipher.length - tagLength);
        byte[] cipherTag = Arrays.copyOfRange(cipher, cipher.length - tagLength, cipher.length);

        Cipher ctrCipher = Cipher.getInstance("AES/CTR/NoPadding");

        IvParameterSpec counter = formatedCounter(nonce);
        ctrCipher.init(Cipher.DECRYPT_MODE, key, counter);

        byte[] tag = ctrCipher.doFinal(cipherTag);

        byte[] counterPlus1Bytes = counter.getIV();
        ++counterPlus1Bytes[counterPlus1Bytes.length - 1];
        IvParameterSpec counterPlus1 = new IvParameterSpec(counterPlus1Bytes);
        ctrCipher.init(Cipher.DECRYPT_MODE, key, counterPlus1);

        byte[] text = ctrCipher.doFinal(cipherText);
        byte[] recalculatedTag = tag(nonce, additionalData, text, tagLength);

        if (Arrays.equals(tag, recalculatedTag)) {
            return text;
        }

        return new byte[0];
    }
}
